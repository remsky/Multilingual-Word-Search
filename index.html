<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>English-Bengali Word Search | Educational Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Noto+Sans+Bengali:wght@400;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-bg': '#F8FAFC',
                        'accent-soft': '#E0F2FE',
                        'accent-main': '#0284C7',
                        'success-pale': '#F0FDF4',
                        'success-deep': '#16A34A',
                        'bengali-orange': '#EA580C',
                        'bengali-blue': '#2563EB',
                        'glass': 'rgba(255, 255, 255, 0.8)',
                    },
                    fontFamily: {
                        sans: ['Outfit', 'sans-serif'],
                        bengali: ['Noto Sans Bengali', 'serif'],
                    },
                    boxShadow: {
                        'premium': '0 10px 25px -5px rgba(0, 0, 0, 0.05), 0 8px 10px -6px rgba(0, 0, 0, 0.05)',
                        'inner-soft': 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --cell-bg: #FFFFFF;
            --cell-hover: #F1F5F9;
            --cell-selected: #FDE047;
            --cell-found: #86EFAC;
            --grid-size: 12;
        }

        body {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            gap: 4px;
            user-select: none;
        }

        .grid-cell {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--cell-bg);
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            color: #334155;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        @media (max-width: 640px) {
            .grid-cell { font-size: 0.85rem; gap: 2px; }
            .grid-container { gap: 2px; }
        }

        .grid-cell:hover:not(.selected):not(.found) {
            background: var(--cell-hover);
            transform: scale(1.05);
        }

        .grid-cell.selected {
            background: var(--cell-selected) !important;
            color: #854d0e;
            transform: scale(0.95);
        }

        .grid-cell.found {
            background: var(--cell-found) !important;
            color: #166534;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0.5; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .word-item {
            transition: all 0.3s ease;
        }

        .word-item.found {
            text-decoration: line-through;
            opacity: 0.6;
            background: #F0FDF4 !important;
            color: #16A34A !important;
            border-color: #BBF7D0 !important;
            cursor: pointer;
        }

        .word-item.found:hover {
            opacity: 1;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(22, 163, 74, 0.2);
        }

        .glass-morphism {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .modal-overlay {
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content {
            animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Scrollbar styling */
        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #CBD5E1;
            border-radius: 10px;
        }
    </style>
</head>
<body class="bg-primary-bg min-h-screen font-sans text-slate-800 antialiased overflow-x-hidden">

    <div class="max-w-6xl mx-auto px-4 py-8 md:py-12">
        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-slate-900 mb-2">
                Word<span class="text-accent-main">Shuffle</span>
            </h1>
            <p class="text-slate-500 font-medium tracking-wide uppercase text-xs">English-Bengali Word Search</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8 items-start">
            <!-- Game Grid Section -->
            <div id="grid-section" class="w-full lg:flex-1 glass-morphism rounded-3xl p-4 md:p-8 shadow-premium">
                <div id="grid-container" class="grid-container mx-auto max-w-[500px]">
                    <!-- JS will populate cells here -->
                </div>
            </div>

            <!-- Sidebar Section -->
            <div class="w-full lg:w-80 flex flex-col gap-6">
                <!-- Word List Card -->
                <div id="word-list-section" class="glass-morphism rounded-3xl p-6 shadow-premium h-fit">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="font-bold text-lg text-slate-800">Words to Find</h2>
                        <span id="found-counter" class="bg-accent-soft text-accent-main text-sm font-bold px-3 py-1 rounded-full">0/10</span>
                    </div>
                    <ul id="word-list" class="flex flex-wrap lg:flex-col gap-2 max-h-[300px] lg:max-h-[500px] overflow-y-auto custom-scrollbar pr-2">
                        <!-- JS will populate word list here -->
                    </ul>
                </div>

                <!-- Instructions/Feedback Hint -->
                <div class="bg-slate-900 rounded-2xl p-6 text-white shadow-xl">
                    <h3 class="font-bold mb-2 flex items-center gap-2">
                        <svg class="w-4 h-4 text-accent-main" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        How to Play
                    </h3>
                    <p class="text-sm text-slate-300 leading-relaxed">
                        Drag across letters horizontally, vertically, or diagonally to select words. Discover new vocabulary in English and Bengali!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Word Details -->
    <div id="modal" class="fixed inset-0 z-50 hidden flex items-center justify-center p-4">
        <div class="absolute inset-0 bg-slate-900/60 backdrop-blur-sm modal-overlay" onclick="closeModal()"></div>
        <div class="relative w-full max-w-lg bg-white rounded-[2rem] shadow-2xl p-8 modal-content">
            <button onclick="closeModal()" class="absolute top-6 right-6 text-slate-400 hover:text-slate-600 transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
            
            <div class="text-center">
                <div class="inline-flex items-center justify-center w-16 h-16 bg-success-pale rounded-2xl mb-6">
                    <svg class="w-8 h-8 text-success-deep" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                </div>
                
                <h2 id="modal-english-word" class="text-3xl font-bold text-slate-900 mb-1">Word</h2>
                <h3 id="modal-bengali-word" class="text-2xl font-bengali text-bengali-orange font-bold mb-6">শব্দ</h3>
                
                <div class="space-y-6 text-left border-t border-slate-100 pt-6">
                    <div>
                        <p class="text-xs font-bold text-slate-400 uppercase tracking-widest mb-2">Meaning (English)</p>
                        <p id="modal-en-explanation" class="text-slate-700 leading-relaxed italic">Explanation...</p>
                    </div>
                    <div>
                        <p class="text-xs font-bold text-slate-400 uppercase tracking-widest mb-2">Bengali Explanation</p>
                        <p id="modal-bn-explanation" class="font-bengali text-slate-700 leading-relaxed text-lg">ব্যাখ্যা...</p>
                    </div>
                </div>

                <button onclick="closeModal()" class="mt-8 w-full bg-slate-900 text-white font-bold py-4 rounded-xl hover:bg-slate-800 transition-all active:scale-95 shadow-lg shadow-slate-200">
                    Keep Exploring
                </button>
            </div>
        </div>
    </div>

    <script>
        const WORDS_DATA = [
            // --- Easy / Familiar ---
            { english: "Hope", bengali: "আশা (Asha)", en_explanation: "A feeling that something good can happen.", bn_explanation: "ভালো কিছু হতে পারে—এই আশা।" },
            { english: "Calm", bengali: "শান্ত (Shanto)", en_explanation: "Peaceful and not upset.", bn_explanation: "শান্ত ও অস্থির নয়।" },
            { english: "Peace", bengali: "শান্তি (Shanti)", en_explanation: "A state of inner quiet or no conflict.", bn_explanation: "মনের শান্তি বা ঝামেলাহীন অবস্থা।" },
            { english: "Joy", bengali: "আনন্দ (Anondo)", en_explanation: "A strong feeling of happiness.", bn_explanation: "আনন্দের অনুভূতি।" },
            { english: "Trust", bengali: "বিশ্বাস (Bishshash)", en_explanation: "Confidence in someone or something.", bn_explanation: "কাউকে বা কিছুকে বিশ্বাস করা।" },
            { english: "Respect", bengali: "সম্মান (Shomman)", en_explanation: "Showing regard and value for someone.", bn_explanation: "কারও প্রতি সম্মান দেখানো।" },
            { english: "Honest", bengali: "সৎ (Shot)", en_explanation: "Truthful and sincere.", bn_explanation: "সত্যবাদী ও আন্তরিক।" },
            { english: "Kindness", bengali: "সদয়তা (Sadayota)", en_explanation: "Being kind and thoughtful.", bn_explanation: "সদয় ও বিবেচনাশীল হওয়ার গুণ।" },
            { english: "Empathy", bengali: "সহমর্মিতা (Shohomormita)", en_explanation: "Understanding another person's feelings.", bn_explanation: "অন্যের অনুভূতি বোঝার ক্ষমতা।" },
            { english: "Caring", bengali: "যত্নশীল (Jotnoshil)", en_explanation: "Showing care for others.", bn_explanation: "যত্ন নিয়ে আচরণ করে এমন।" },
            { english: "Gentle", bengali: "নম্র (Nomro)", en_explanation: "Soft in manner; not harsh.", bn_explanation: "নম্র ও কঠোর নয়।" },
            { english: "Rest", bengali: "বিশ্রাম (Bishram)", en_explanation: "Time to relax and recover.", bn_explanation: "শরীর-মনকে আরাম দেওয়ার সময়।" },
            { english: "Sleep", bengali: "ঘুম (Ghum)", en_explanation: "Natural rest for body and mind.", bn_explanation: "শরীর-মন বিশ্রামের ঘুম।" },
            { english: "Breath", bengali: "শ্বাস (Shash)", en_explanation: "Air taken in and out of the body.", bn_explanation: "শ্বাস নেওয়া ও ছাড়া।" },
            { english: "Relax", bengali: "আরাম করা (Aram Kora)", en_explanation: "To become less tense.", bn_explanation: "টান কমিয়ে আরাম করা।" },
            { english: "Smile", bengali: "হাসি (Hashi)", en_explanation: "A happy or warm facial expression.", bn_explanation: "মুখের মিষ্টি হাসি।" },
            { english: "Friend", bengali: "বন্ধু (Bondhu)", en_explanation: "A person you trust and like.", bn_explanation: "বিশ্বাসের ও কাছের মানুষ।" },
            { english: "Family", bengali: "পরিবার (Poribar)", en_explanation: "People closely related to you.", bn_explanation: "আপনার কাছের পরিবারের মানুষজন।" },
            { english: "Share", bengali: "ভাগ করা (Bhag Kora)", en_explanation: "To give part of something or express with others.", bn_explanation: "অন্যের সঙ্গে ভাগ করে নেওয়া।" },
            { english: "Listen", bengali: "শোনা (Shona)", en_explanation: "To pay attention to sound or someone's words.", bn_explanation: "মন দিয়ে শোনা।" },
            // --- Medium / Common ---
            { english: "Patience", bengali: "ধৈর্য (Dhoirjo)", en_explanation: "Staying steady during delay or difficulty.", bn_explanation: "দেরি বা কষ্টের সময় ধৈর্য রাখা।" },
            { english: "Courage", bengali: "সাহস (Sahos)", en_explanation: "Acting despite fear.", bn_explanation: "ভয় থাকলেও এগিয়ে যাওয়া।" },
            { english: "Effort", bengali: "চেষ্টা (Cheshta)", en_explanation: "Work done to achieve something.", bn_explanation: "কিছু করার জন্য চেষ্টা।" },
            { english: "Focus", bengali: "মনোযোগ (Monojog)", en_explanation: "Careful attention.", bn_explanation: "মন দিয়ে খেয়াল করা।" },
            { english: "Learn", bengali: "শেখা (Shekha)", en_explanation: "To gain knowledge or skill.", bn_explanation: "জ্ঞান বা দক্ষতা অর্জন করা।" },
            { english: "Skill", bengali: "দক্ষতা (Dokkhota)", en_explanation: "Ability to do something well.", bn_explanation: "ভালোভাবে কিছু করার ক্ষমতা।" },
            { english: "Plan", bengali: "পরিকল্পনা (Porikolpona)", en_explanation: "A way of organizing what to do.", bn_explanation: "আগে থেকে ভেবে কাজের ব্যবস্থা করা।" },
            { english: "Habit", bengali: "অভ্যাস (Obhyash)", en_explanation: "Something done regularly.", bn_explanation: "যা নিয়মিত করা হয়।" },
            { english: "Routine", bengali: "দৈনন্দিন অভ্যাস (Doinondin Obhyash)", en_explanation: "A usual set of daily actions.", bn_explanation: "প্রতিদিনের নিয়মিত কাজের ধারা।" },
            { english: "Balance", bengali: "ভারসাম্য (Bhorshammo)", en_explanation: "A stable and healthy middle state.", bn_explanation: "সুষম ও স্থির অবস্থা।" },
            { english: "Health", bengali: "স্বাস্থ্য (Shastho)", en_explanation: "Condition of body and mind.", bn_explanation: "শরীর ও মনের সুস্থতা।" },
            { english: "Healing", bengali: "সুস্থতা (Shusthota)", en_explanation: "Getting better over time.", bn_explanation: "ধীরে ধীরে ভালো হয়ে ওঠা।" },
            { english: "Support", bengali: "সহায়তা (Shohayota)", en_explanation: "Help or encouragement.", bn_explanation: "সাহায্য বা ভরসা।" },
            { english: "Speak", bengali: "বলা (Bola)", en_explanation: "To say words or express thoughts.", bn_explanation: "কথা বলা বা ভাব প্রকাশ করা।" },
            { english: "Reason", bengali: "যুক্তি (Jukti)", en_explanation: "A clear thinking basis for something.", bn_explanation: "কোনো কিছুর যুক্তিসঙ্গত কারণ।" },
            { english: "Memory", bengali: "স্মৃতি (Smriti)", en_explanation: "The ability to remember.", bn_explanation: "মনে রাখার ক্ষমতা বা স্মরণ।" },
            { english: "Choice", bengali: "পছন্দ (Pochondo)", en_explanation: "A decision between options.", bn_explanation: "বিকল্পের মধ্যে বেছে নেওয়া।" },
            { english: "Decide", bengali: "সিদ্ধান্ত নেওয়া (Shiddhanto Newa)", en_explanation: "To make a choice.", bn_explanation: "সিদ্ধান্ত করা।" },
            { english: "Change", bengali: "পরিবর্তন (Poriborton)", en_explanation: "To become different.", bn_explanation: "আগের চেয়ে ভিন্ন হওয়া।" },
            { english: "Grow", bengali: "বেড়ে ওঠা (Bere Otha)", en_explanation: "To develop over time.", bn_explanation: "সময়ের সাথে উন্নত হওয়া বা বড় হওয়া।" },
            // --- Slight Stretch ---
            { english: "Growth", bengali: "বিকাশ (Bikash)", en_explanation: "Steady development.", bn_explanation: "ধীরে ধীরে উন্নতি বা বিকাশ।" },
            { english: "Improve", bengali: "উন্নতি করা (Unnoto Kora)", en_explanation: "To make better.", bn_explanation: "আরও ভালো করা।" },
            { english: "Create", bengali: "তৈরি করা (Toiri Kora)", en_explanation: "To make something new.", bn_explanation: "নতুন কিছু তৈরি করা।" },
            { english: "Value", bengali: "মূল্য (Mullo)", en_explanation: "Importance or worth.", bn_explanation: "গুরুত্ব বা মূল্য।" },
            { english: "Fairness", bengali: "ন্যায্যতা (Nyajjota)", en_explanation: "Being just and reasonable.", bn_explanation: "ন্যায়সঙ্গত ও যুক্তিযুক্ত হওয়া।" },
            { english: "Duty", bengali: "দায়িত্ব (Dayitto)", en_explanation: "A responsibility.", bn_explanation: "দায়িত্ব বা কর্তব্য।" },
            { english: "Accept", bengali: "মেনে নেওয়া (Mene Newa)", en_explanation: "To allow or understand something as it is.", bn_explanation: "যেমন আছে তেমন মেনে নেওয়া।" },
            { english: "Adjust", bengali: "মানিয়ে নেওয়া (Maniye Newa)", en_explanation: "To adapt to a situation.", bn_explanation: "পরিস্থিতির সঙ্গে মানিয়ে নেওয়া।" },
            { english: "Steady", bengali: "স্থির (Sthir)", en_explanation: "Stable and not easily shaken.", bn_explanation: "স্থির ও সহজে নড়ে না।" },
            { english: "Strong", bengali: "শক্ত (Shokto)", en_explanation: "Having strength.", bn_explanation: "শক্তি আছে এমন।" },
            { english: "Secure", bengali: "নিরাপদ (Nirapod)", en_explanation: "Safe and protected.", bn_explanation: "নিরাপদ ও সুরক্ষিত।" },
            { english: "Simple", bengali: "সহজ (Shohoj)", en_explanation: "Not complicated.", bn_explanation: "জটিল নয়; সহজ।" },
            { english: "Useful", bengali: "উপকারী (Upokari)", en_explanation: "Helpful or practical.", bn_explanation: "কাজে লাগে এমন; উপকারী।" },
            { english: "Active", bengali: "সক্রিয় (Shokriyo)", en_explanation: "Doing things; engaged.", bn_explanation: "কাজে যুক্ত ও সক্রিয়।" },
            { english: "Curious", bengali: "কৌতূহলী (Koutuholi)", en_explanation: "Interested in learning or knowing.", bn_explanation: "জানতে আগ্রহী।" },
            { english: "Bright", bengali: "উজ্জ্বল (Ujjol)", en_explanation: "Full of light; also mentally sharp.", bn_explanation: "উজ্জ্বল; তীক্ষ্ণ বুদ্ধিসম্পন্ন।" },
            { english: "Clever", bengali: "চতুর (Chotur)", en_explanation: "Quick to understand.", bn_explanation: "দ্রুত বুঝতে পারে এমন।" },
            { english: "Present", bengali: "উপস্থিত (Uposthit)", en_explanation: "Being here now; in the moment.", bn_explanation: "এখন এখানে থাকা; বর্তমান থাকা।" },
            { english: "Wisdom", bengali: "প্রজ্ঞা (Proggya)", en_explanation: "Good judgment from experience.", bn_explanation: "অভিজ্ঞতা থেকে আসা ভালো বিচারবোধ।" },
            { english: "Insight", bengali: "অন্তর্দৃষ্টি (Ontordrishti)", en_explanation: "A clear understanding of something.", bn_explanation: "কোনো কিছু গভীরভাবে বুঝতে পারা।" },
        ];

        const GRID_ROWS = 12;
        const GRID_COLS = 12;
        let grid = Array(GRID_ROWS).fill().map(() => Array(GRID_COLS).fill(''));
        let selectedWords = [];
        let foundWords = new Set();
        let isSelecting = false;
        let startCellCoords = null;
        let currentPath = [];

        const gridContainer = document.getElementById('grid-container');
        const wordListElement = document.getElementById('word-list');
        const modal = document.getElementById('modal');
        const foundCounter = document.getElementById('found-counter');

        function init() {
            generateGrid();
            renderWordList();
            setupEventListeners();
        }

        function generateGrid() {
            const directions = [
                [0, 1], [1, 0], [1, 1], [-1, 1],
                [0, -1], [-1, 0], [-1, -1], [1, -1]
            ];

            // Pick 10 random words that fit within the grid dimensions
            const maxWordLen = Math.min(GRID_ROWS, GRID_COLS);
            const eligible = WORDS_DATA.filter(w => w.english.length <= maxWordLen);

            // Retry the entire layout until all words are placed (or max retries reached)
            for (let attempt = 0; attempt < 20; attempt++) {
                // Reset grid
                for (let r = 0; r < GRID_ROWS; r++)
                    for (let c = 0; c < GRID_COLS; c++)
                        grid[r][c] = '';

                const shuffled = [...eligible];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                selectedWords = shuffled.slice(0, Math.min(10, shuffled.length));

                const sortedWords = selectedWords.map(w => w.english.toUpperCase()).sort((a, b) => b.length - a.length);
                let allPlaced = true;

                for (const word of sortedWords) {
                    let placed = false;
                    let tries = 0;
                    while (!placed && tries < 200) {
                        const dir = directions[Math.floor(Math.random() * directions.length)];
                        const r = Math.floor(Math.random() * GRID_ROWS);
                        const c = Math.floor(Math.random() * GRID_COLS);
                        if (canPlace(word, r, c, dir)) {
                            for (let i = 0; i < word.length; i++) {
                                grid[r + i * dir[0]][c + i * dir[1]] = word[i];
                            }
                            placed = true;
                        }
                        tries++;
                    }

                    // Systematic fallback: try every position and direction if random failed
                    if (!placed) {
                        for (let r = 0; r < GRID_ROWS && !placed; r++) {
                            for (let c = 0; c < GRID_COLS && !placed; c++) {
                                for (let d = 0; d < directions.length && !placed; d++) {
                                    const dir = directions[d];
                                    if (canPlace(word, r, c, dir)) {
                                        for (let i = 0; i < word.length; i++) {
                                            grid[r + i * dir[0]][c + i * dir[1]] = word[i];
                                        }
                                        placed = true;
                                    }
                                }
                            }
                        }
                    }

                    if (!placed) { allPlaced = false; break; }
                }

                if (allPlaced) break;
            }

            // Fill empty
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }
            }

            renderGrid();
        }

        function canPlace(word, r, c, dir) {
            const endR = r + (word.length - 1) * dir[0];
            const endC = c + (word.length - 1) * dir[1];
            if (endR < 0 || endR >= GRID_ROWS || endC < 0 || endC >= GRID_COLS) return false;

            for (let i = 0; i < word.length; i++) {
                const currR = r + i * dir[0];
                const currC = c + i * dir[1];
                if (grid[currR][currC] !== '' && grid[currR][currC] !== word[i]) return false;
            }
            return true;
        }

        function renderGrid() {
            gridContainer.innerHTML = '';
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = grid[r][c];
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    gridContainer.appendChild(cell);
                }
            }
        }

        function renderWordList() {
            wordListElement.innerHTML = '';
            selectedWords.forEach(word => {
                const li = document.createElement('li');
                li.className = 'word-item bg-white px-4 py-2 rounded-xl text-sm font-semibold shadow-sm border border-slate-100 text-slate-600';
                li.id = `word-${word.english.toUpperCase()}`;
                li.textContent = word.english;
                li.addEventListener('click', () => {
                    if (foundWords.has(word.english.toUpperCase())) {
                        showModal(word);
                    }
                });
                wordListElement.appendChild(li);
            });
        }

        function setupEventListeners() {
            gridContainer.addEventListener('mousedown', startSelection);
            gridContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('grid-cell')) {
                    startSelection({ target });
                }
            });

            window.addEventListener('mousemove', moveSelection);
            window.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('grid-cell')) {
                    moveSelection({ target });
                }
            });

            window.addEventListener('mouseup', endSelection);
            window.addEventListener('touchend', endSelection);

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeModal();
            });
        }

        function startSelection(e) {
            if (!e.target.classList.contains('grid-cell')) return;
            isSelecting = true;
            startCellCoords = {
                r: parseInt(e.target.dataset.row),
                c: parseInt(e.target.dataset.col)
            };
            highlightSelection(startCellCoords, startCellCoords);
        }

        function moveSelection(e) {
            if (!isSelecting || !e.target.classList.contains('grid-cell')) return;
            const currentCoords = {
                r: parseInt(e.target.dataset.row),
                c: parseInt(e.target.dataset.col)
            };
            highlightSelection(startCellCoords, currentCoords);
        }

        function highlightSelection(start, end) {
            const dr = end.r - start.r;
            const dc = end.c - start.c;
            
            // Check if it's a straight line (horizontal, vertical, or 45-deg diagonal)
            if (dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return;

            const steps = Math.max(Math.abs(dr), Math.abs(dc));
            const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
            const stepC = dc === 0 ? 0 : dc / Math.abs(dc);

            clearCurrentSelection();
            currentPath = [];

            for (let i = 0; i <= steps; i++) {
                const r = start.r + i * stepR;
                const c = start.c + i * stepC;
                const cell = getCell(r, c);
                if (cell) {
                    cell.classList.add('selected');
                    currentPath.push({ r, c, char: grid[r][c] });
                }
            }
        }

        function clearCurrentSelection() {
            document.querySelectorAll('.grid-cell.selected').forEach(el => el.classList.remove('selected'));
        }

        function endSelection() {
            if (!isSelecting) return;
            isSelecting = false;

            const selectedWord = currentPath.map(p => p.char).join('');
            const reversedWord = selectedWord.split('').reverse().join('');
            
            const match = selectedWords.find(w => 
                (w.english.toUpperCase() === selectedWord || w.english.toUpperCase() === reversedWord) && 
                !foundWords.has(w.english.toUpperCase())
            );

            if (match) {
                const wordKey = match.english.toUpperCase();
                foundWords.add(wordKey);
                
                // Mark cells as found
                currentPath.forEach(p => {
                    getCell(p.r, p.c).classList.add('found');
                });

                // Update word list
                const listItem = document.getElementById(`word-${wordKey}`);
                if (listItem) listItem.classList.add('found');

                // Update counter
                foundCounter.textContent = `${foundWords.size}/${selectedWords.length}`;

                // Show Modal
                showModal(match);
            }

            clearCurrentSelection();
            currentPath = [];
        }

        function getCell(r, c) {
            return document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
        }

        function showModal(data) {
            document.getElementById('modal-english-word').textContent = data.english;
            document.getElementById('modal-bengali-word').textContent = data.bengali;
            document.getElementById('modal-en-explanation').textContent = data.en_explanation;
            document.getElementById('modal-bn-explanation').textContent = data.bn_explanation;
            modal.classList.remove('hidden');
        }

        function closeModal() {
            modal.classList.add('hidden');
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
